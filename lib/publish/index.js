// Generated by CoffeeScript 1.9.1
var Changelog, Git, Npm, async, commitChanges, debug, fs, isPrivate, openEditor, prep, prompt, test, updateVersion, verify;

fs = require('fs');

async = require('async');

debug = require('debug')('publish');

prep = require('../prep');

verify = require('../verify');

Changelog = require('./changelog');

openEditor = require('./editor');

updateVersion = require('./version');

commitChanges = require('./commit-changes');

Npm = require('./npm');

Git = require('../git');

test = require('./test');

prompt = require('./prompt');

isPrivate = require('./public');

module.exports = function(dir, log, config, version, testCommand) {
  var changelog, git, npm;
  debug("start");
  git = Git(dir);
  npm = Npm(dir, log);
  changelog = Changelog(dir, git);
  if (isPrivate(dir)) {
    log('cannot publish this package because it is private.');
    process.exit(2);
  }
  return async.waterfall([
    function(done) {
      return verify(dir, done);
    }, function(done) {
      prep(dir, log, config);
      debug('ensured license headers');
      return done();
    }, function(done) {
      return verify(dir, done);
    }, function(done) {
      return npm.install(config.registry, done);
    }, function(done) {
      return test(dir, log, npm, testCommand, done);
    }, function(done) {
      return changelog.build(version, done);
    }, function(tempChangelog, done) {
      return git.getSha(function(error, sha) {
        return done(error, tempChangelog, sha);
      });
    }, function(tempChangelog, sha, done) {
      var tempChangelogPath;
      tempChangelogPath = "/tmp/npub/changelog-" + sha + ".md";
      changelog.write(tempChangelog, tempChangelogPath);
      return done(null, tempChangelogPath);
    }, function(tempChangelogPath, done) {
      return openEditor(tempChangelogPath, function(error) {
        if (error != null) {
          fs.unlinkSync(tempChangelogPath);
          return done(error);
        }
        changelog.update(tempChangelogPath);
        updateVersion(dir, version);
        return done();
      });
    }, function(done) {
      var tag;
      tag = "v" + version;
      return commitChanges(git, tag, function(error) {
        return done(error, tag);
      });
    }, function(tag, done) {
      return git.tag(tag, function(error) {
        return done(error, tag);
      });
    }, function(tag, done) {
      return prompt(version, function(error) {
        return done(error, tag);
      });
    }, function(tag, done) {
      return git.remoteBranch(function(error, remoteBranch) {
        var branch, ref, remote;
        ref = remoteBranch != null ? remoteBranch.split('/') : void 0, remote = ref[0], branch = ref[1];
        return done(error, remote, branch, tag);
      });
    }, function(remote, branch, tag, done) {
      return git.push(remote, branch, function(error) {
        return done(error, remote, tag);
      });
    }, function(remote, tag, done) {
      return git.pushTag(remote, tag, done);
    }, function(done) {
      return npm.publish(done);
    }
  ], function(error) {
    if (error != null) {
      log.error(error.message);
      process.exit(1);
    }
    return log('success!');
  });
};
